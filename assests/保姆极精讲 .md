# 保姆极精讲

# 12.6 Copying Objects（保姆级彻底讲清）

> 核心问题只有一句话：
> 
> 
> **“当一个对象里面有指针（指向 heap）时，‘拷贝’到底意味着什么？”**
> 

---

## 一、什么叫“拷贝对象”？

在 C++ 中，**对象被拷贝**，只会发生在这两种情况：

### 情况 1：赋值（assignment）

```cpp
CharStack s1;
CharStack s2;

s2 = s1;// assignment operator

```

---

### 情况 2：按值传参 / 按值返回

```cpp
voidf(CharStack s);// call by value

f(s1);// copy constructor 被调用

```

---

## 二、如果你什么都不写，会发生什么？

这是**最重要的起点**。

> 如果你不写 copy constructor 和 operator=，
C++ 会帮你“自动生成”一个。
> 

### 这个“默认拷贝”做了什么？

**逐个 field 拷贝（bitwise copy）**。

---

## 三、用 CharStack 看“默认拷贝”的灾难

### CharStack 的内部结构（关键）

```cpp
classCharStack {
private:
char* array;// 指向 heap
int capacity;
int count;
};

```

---

### 假设你写了：

```cpp
CharStack s1;
CharStack s2 = s1;// copy constructor

```

### 默认拷贝的真实行为是：

```
s2.array   = s1.array    // 只拷贝地址
s2.count   = s1.count
s2.capacity= s1.capacity

```

**注意：array 里的内容没有被复制！**

---

## 四、这就是 Shallow Copy（浅拷贝）

### 定义（考试级）

> Shallow copy copies only the top-level fields of an object.
For pointer fields, only the address is copied, not the data.
> 

---

### 内存后果（你脑子里必须有）

```
s1.array ──┐
           ├──> heap 上同一块内存
s2.array ──┘

```

---

## 五、为什么 Shallow Copy 一定会出大问题？

### 问题 1：Double Free（必考）

```cpp
{
    CharStack s1;
    CharStack s2 = s1;
}// 两个 destructor 被调用

```

发生了什么？

- s2 析构 → delete[] array
- s1 析构 → 再 delete[] 同一块内存

结果：

> Undefined Behavior / crash
> 

---

### 问题 2：互相污染数据

```cpp
s2.push('A');

```

你以为只改 s2，

实际上 **s1 的数据也被改了**。

---

## 六、正确的语义是什么？（关键转折）

PPT 明确说了一句非常重要的话：

> Collection classes should have deep copy semantics.
> 

也就是说：

> 拷贝一个对象 = 得到一个“完全独立”的新对象
> 

---

## 七、什么是 Deep Copy（深拷贝）？

### 定义（考试级）

> Deep copy duplicates not only the object fields,
but also the dynamically allocated memory they point to.
> 

---

### 内存结构对比

### Shallow Copy

```
s1.array ──┐
           ├──> same heap block
s2.array ──┘

```

### Deep Copy

```
s1.array ──>heapblockA
s2.array ──>heapblockB// 独立

```

---

## 八、C++ 要你手动做什么？

只要你的类：

- **自己管理 heap 内存**
- **里面有 raw pointer**

你就**必须**写这两个东西：

---

### 1️⃣ Copy Constructor

```cpp
CharStack::CharStack(const CharStack& src) {
deepCopy(src);
}

```

什么时候调用？

- 对象被 **按值拷贝** 时
- 用已有对象初始化新对象时

---

### 2️⃣ Assignment Operator

```cpp
CharStack& CharStack::operator=(const CharStack& src) {
if (this != &src) {
delete[] array;
deepCopy(src);
    }
return *this;
}

```

什么时候调用？

- 已存在对象 ← 另一个对象

---

## 九、为什么 assignment operator 要这么复杂？

### 问题 1：为什么要 `this != &src`？

```cpp
s = s;

```

如果不判断：

- 你先 delete 自己的 array
- 再从 src（其实是自己）拷贝
- 数据已经没了

---

### 问题 2：为什么要先 delete？

因为：

- 原来对象已经占着一块 heap
- 不 delete → memory leak

---

### 问题 3：为什么返回 `this`？

因为 C++ 约定：

```cpp
a = b = c;

```

需要支持链式赋值。

---

## 十、deepCopy 函数到底在干嘛？

PPT 里的标准写法：

```cpp
voidCharStack::deepCopy(const CharStack& src) {
    array =new char[src.capacity];
for (int i =0; i < src.count; i++) {
        array[i] = src.array[i];
    }
    count = src.count;
    capacity = src.capacity;
}

```

一句话解释：

> 申请新的 heap → 把数据一个一个复制过去
> 

---

## 十一、一个“万能判断法”（非常重要）

以后你看到一个类，直接问自己一句：

> “这个类里有没有 raw pointer 指向 heap？”
> 
- 没有 → 默认拷贝通常没问题
- 有 →
    
    必须考虑：
    
    - destructor
    - copy constructor
    - assignment operator

这就是著名的 **Rule of Three**。

---

## 十二、考试级终极总结（你可以直接背）

> In C++, the default copy behavior performs shallow copying,
> 
> 
> which copies only pointer values and leads to shared dynamic memory.
> 
> For classes that manage heap-allocated memory, shallow copying is unsafe.
> 
> Therefore, such classes must implement a copy constructor and an assignment operator to perform deep copying, ensuring that each object owns its own copy of the dynamic data.
>